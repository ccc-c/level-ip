# 讓我們來寫一個 TCP/IP 堆疊，3：TCP 基礎知識和握手

現在我們的用戶空間 TCP/IP 堆疊已經實現了乙太網路和 IPv4 的最小化，是時候研究一下可怕的傳輸控制協定 (TCP) 了。

TCP 在第四個 OSI 網路第 1層（傳輸層）上運行，負責修復資料包傳送中的錯誤連線和故障。事實上，TCP 是互聯網的主力，在當今幾乎所有電腦網路中提供可靠的通訊。

TCP 並不完全是新協定－第一個規範於 1974 年發布2。從那時起，發生了很多變化，TCP 已經獲得了許多擴展和修正3。

這篇文章將深入探討 TCP 背後的基本理論，並嘗試為其設計提供動力。此外，我們將研究 TCP 標頭並討論建立連線（TCP 握手）。最後一步，我們將示範網路堆疊中 TCP 的第一個功能。

## 可靠性機制
可靠發送資料的問題看似表面，但涉及其實際的實現。主要是，在資料報式網路中的錯誤修復方面出現了幾個問題：

1. 發送方應等待接收方確認多久？
2. 如果接收方處理資料的速度無法趕上發送資料的速度怎麼辦？
3. 如果中間的網路（例如路由器）無法像發送資料一樣快速處理資料怎麼辦？

在所有情況下，資料包交換網路都存在潛在的危險——來自接收方的確認可能在傳輸過程中被損壞甚至遺失，這使發送方陷入棘手的境地。

為了解決這些問題，可以使用多種機制。也許最常見的是滑動視窗技術，雙方都對傳輸的資料進行記錄。視窗資料被認為是連續的（就像數組的切片），並且當雙方處理（並確認）資料時，視窗向前「滑動」：

```
                 Left window edge             Right window edge
                       |                             |
                       |                             |
          ---------------------------------------------------------
          ...|    3    |    4    |    5    |    6    |    7    |...
          ---------------------------------------------------------
                  ^     ^                            ^    ^
                  |      \                          /     |
                  |       \                        /      |
             Sent and           Window size: 3         Cannot be
             ACKed                                     sent yet
```

使用這種滑動視窗的便利特性是它還減輕了流量控制的問題。當接收方處理資料的速度無法達到發送資料的速度時，就需要進行流量控制。在這種情況下，滑動視窗的大小將協商得較小，從而導致發送方的輸出受到限制。

另一方面，擁塞控制有助於發送方和接收方之間的網路堆疊不會發生擁塞。有兩種通用方法：在明確版本中，協定有一個欄位用於專門通知發送者有關擁塞狀態的資訊。在隱式版本中，發送方嘗試猜測網路何時擁塞並應限制其輸出。整體而言，擁塞控制是一個複雜的、反覆出現的網路問題，相關研究至今仍在進行中。4

## TCP 基礎知識

TCP 中的底層機制比 UDP 和 IP 等其他協定涉及更多。即，TCP是面向連接的協議，這意味著首先在正好兩端之間建立單播通訊通道。這個連結是由雙方主動處理的：建立連結（握手），告知對方資料的狀態和可能出現的問題。

TCP 的另一個重要屬性是它是一種流協定。與 UDP 不同，TCP 不保證應用程式在發送和接收資料時保持穩定的資料「區塊」。相反，TCP 實作必須緩衝數據，當資料包遺失、重新排序或損壞時，TCP 必須等待並組織緩衝區中的資料。只有當資料被認為是完整的時，TCP才可以將資料交給應用程式的套接字。

由於 TCP 將資料作為流進行操作，因此流中的「區塊」必須轉換為 IP 可以承載的資料包。這稱為打包，其中 TCP 標頭包含流中當前索引的序號。這還有一個方便的特性，流可以分成許多可變大小的段，然後 TCP 知道如何重新打包它們。

與 IP 類似，TCP 也檢查訊息的完整性。這是透過與 IP 中相同的校驗和演算法來實現的，但增加了細節。主要是，校驗和是端到端的，這意味著標頭和資料都包含在校驗和中。此外，還包括根據 IP 標頭建構的偽標頭。

如果 TCP 實作接收到損壞的段，它會丟棄它們並且不會通知發送方。這個錯誤可以透過發送方設定的定時器來修正，如果接收方從未確認過該報文段，則可以使用該定時器來重新傳輸該報文段。

TCP 也是一個全雙工系統，這意味著流量可以同時在兩個方向上流動。這意味著通訊雙方必須在記憶體中保持雙向資料的排序。更深入地說，TCP 透過在其發送的段中包含對相反流量的確認來保留其流量足跡。

從本質上講，資料流的排序是 TCP 的主要原理。然而，保持同步的問題並不是一個簡單的問題。

## TCP 標頭格式
接下來，我們將定義訊息標頭並描述其欄位。 TCP頭看似簡單，但是包含了許多關於通訊狀態的資訊。

TCP 標頭為 20 個八位元組，大小為5：

```
        0                            15                              31
       -----------------------------------------------------------------
       |          source port          |       destination port        |
       -----------------------------------------------------------------
       |                        sequence number                        |
       -----------------------------------------------------------------
       |                     acknowledgment number                     |
       -----------------------------------------------------------------
       |  HL   | rsvd  |C|E|U|A|P|R|S|F|        window size            |
       -----------------------------------------------------------------
       |         TCP checksum          |       urgent pointer          |
       -----------------------------------------------------------------
```

來源連接埠和目標連接埠欄位用於建立來自和到主機的多個連線。也就是說，Berkeley 套接字是應用程式綁定到 TCP 網路堆疊的流行介面。透過端口，網路堆疊知道將流量定向到哪裡。由於欄位大小為 16 位，因此連接埠值的範圍為 0 到 65535。

由於流中的每個位元組都有編號，因此序號代表 TCP 段的視窗索引。握手時，它包含初始序號(ISN)。

確認號包含發送方期望接收的下一個位元組的視窗索引。握手後，必須始終填入 ACK 欄位。

標頭長度(HL)欄位以 32 位元字表示標頭的長度。

接下來，展示了幾個標誌。前 4 位 ( rsvd ) 未使用。

1. 擁塞視窗降低(C)用於通知發送方降低了其發送速率。
2. ECN Echo (E) 通知發送者收到擁塞通知。
3. 緊急指針（U）指示該段包含優先級資料。
4. ACK (A) 欄位用於傳達 TCP 握手的狀態。它在連線的剩餘時間內保持開啟。
5. PSH（P）用於指示接收方應盡快將資料「推送」到應用程式。
6. RST (R) 重設 TCP 連線。
7. SYN (S)用於初始握手時同步序號。
8. FIN (F)表示發送方已完成資料傳送。

視窗大小欄位用於通告視窗大小。換句話說，這是接收方願意接受的位元組數。由於它是 16 位元字段，因此最大視窗大小為 65,535 位元組。

TCP 校驗和欄位用於驗證 TCP 段的完整性。此演算法與 Internet 協定相同，但輸入段也包含 TCP 資料以及來自 IP 資料封包的偽標頭。

當設定 U 標誌時，使用緊急指針。此指標指示緊急資料在流程中的位置。

在標題之後，可以提供幾個選項。這些選項的一個範例是最大分段大小(MSS)，其中發送方通知另一方分段的最大大小。

在可能的選項之後，接下來是實際數據。然而，該數據不是必需的。例如，握手僅透過 TCP 標頭完成。

## TCP握手
TCP連線通常會經歷以下階段：連線建立（握手）、資料傳輸和連線關閉。下圖描述了 TCP 通常的握手例程：

```
          TCP A                                                TCP B
    	  
    1.  CLOSED                                               LISTEN
    	
    2.  SYN-SENT    --> <SEQ=100><CTL=SYN>               --> SYN-RECEIVED
    	  
    3.  ESTABLISHED <-- <SEQ=300><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED
    			
    4.  ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK>       --> ESTABLISHED
    			  
    5.  ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK><DATA> --> ESTABLISHED
```

1. 主機 A 的套接字處於關閉狀態，這表示它不接受連線。相反，主機 B 綁定到特定連接埠的套接字正在偵聽新連線。
2. 主機 A 打算啟動與主機 B 的連線。
3. 主機 B 使用設定了 SYN 和 ACK 欄位的 TCP 段進行回應，並透過向其新增 1 來確認 A 的序號 (ACK=101)。同樣，B 產生序號（300）。
4. 3 次握手由連線請求發起者 (A) 的 ACK 完成。確認欄位反映了主機接下來期望從另一端接收的序號。
5. 數據開始流動，主要是雙方都確認了對方的段號。

這是建立TCP連線的常見場景。然而，出現了幾個問題：

1. 初始序號是如何選擇的？
2. 如果雙方同時要求彼此連線怎麼辦？
3. 路段延遲一段時間或無限期怎麼辦？

初始序號( ISN) 由通訊雙方在第一次聯繫時獨立選擇。由於它是識別連接的關鍵部分，因此必須選擇它，使其最有可能是唯一的且不易被猜測。事實上，在TCP 序號攻擊6中，攻擊者可以複製 TCP 連線並有效地將資料傳送給目標，冒充受信任的主機。

最初的規格建議 ISN 由每 4 微秒遞增的計數器選擇。然而，攻擊者可以猜測到這一點。實際上，現代網路堆疊透過更複雜的方法產生 ISN。

兩個端點收到對方的連線請求（SYN）的情況稱為同時開啟。這是透過 TCP 握手中的額外訊息交換來解決的：雙方都發送 ACK（不知道另一方也已完成），並且雙方對請求進行 SYN-ACK。此後，資料傳輸開始。

最後，TCP 實作必須有一個計時器來知道何時放棄建立連線。嘗試重新建立連接，通常採用指數退避，但一旦達到最大重試次數或時間閾值，連接將被視為不存在。

## TCP 選項
TCP 標頭段中的最後一個欄位是為可能的 TCP 選項保留的。最初的規範提供了三個選項，但後來的規範增加了更多選項。接下來，我們將看看最常見的選項。

最大段大小(MSS)選項告知 TCP 實作願意接收的最大 TCP 段大小。 IPv4 中的典型值為 1460 位元組。

選擇性確認(SACK)選項最佳化了當許多資料包在傳輸過程中遺失且接收器的資料視窗充滿「漏洞」時的情況。為了彌補由此造成的吞吐量下降，TCP 實作可以透過 SACK 通知發送者它未收到的特定資料包。因此，發送方以比累積確認方案更直接的方式接收有關資料狀態的資訊。

視窗縮放選項增加了有限的 16 位元視窗大小。也就是說，如果雙方在握手段中都包含此選項，則視窗大小將乘以此比例。擁有更大的視窗大小對於大量資料傳輸非常重要。

時間戳選項允許發送方將時間戳放入 TCP 段中，然後可用於計算每個 ACK 段的 RTT。然後可以使用該資訊來計算 TCP 重傳逾時。

## 測試 TCP 握手
現在我們已經模擬了 TCP 握手例程並且它有效地偵聽每個端口，讓我們測試一下：

```sh
[saminiir@localhost ~]$ nmap -Pn 10.0.0.4 -p 1337

Starting Nmap 7.00 ( https://nmap.org ) at 2016-05-08 19:02 EEST
Nmap scan report for 10.0.0.4
Host is up (0.00041s latency).
PORT     STATE SERVICE
1337/tcp open  waste

Nmap done: 1 IP address (1 host up) scanned in 0.05 seconds
```

由於 nmap 會進行 SYN 掃描（它只等待 SYN-ACK 來決定目標端口是否打開），因此很容易欺騙它，認為我們有一個應用程式正在偵聽該端口，只需返回一個SYN-ACK TCP 段。

## 結論
只需選擇序號、設定 SYN-ACK 標誌並計算所得 TCP 段的校驗和，即可相對輕鬆地完成最小可行 TCP 握手例程。

下次，我們將探討 TCP 最重要的職責：可靠的資料傳輸。管理流程的視窗對於使用 TCP 傳輸資料至關重要，其邏輯可能會變得有些複雜。

此外，為應用程式提供了一種綁定到 TCP 實現的方法，這是透過套接字完成的。因此，我們將研究 Berkeley Socket API，看看是否可以為應用程式模擬它，使它們能夠使用我們的自訂 TCP 實作。

該專案的源代碼託管在GitHub上。

如果您喜歡這篇文章，您可以 與您的追蹤者分享 並 在 Twitter 上關注我！

## 來源
* https://en.wikipedia.org/wiki/OSI_model  ↩
* https://tools.ietf.org/html/rfc675  ↩
* https://tools.ietf.org/html/rfc7414  ↩
* https://en.wikipedia.org/wiki/TCP/IP_Illustration#Volume_1:_The_Protocols  ↩
* http://www.tcpdump.org/tcpdump_man.html  ↩
* http://www.ietf.org/rfc/rfc1948.txt  ↩